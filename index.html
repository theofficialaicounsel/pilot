<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5.0,user-scalable=yes" />
  <title>AI Mind Map — Streaming Fullscreen Auto-Scroll</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <style>
    /* Theme & layout */
    *{box-sizing:border-box;margin:0;padding:0}
    :root{
      --bg:#0a0a0a; --glass:rgba(26,26,26,0.86);
      --yellow:#ffd700; --text:#fff; --border:rgba(255,215,0,0.28);
      --blue:#6496ff;
      --card-min-height:180px;
    }
    html,body{height:100%}
    body{font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text);display:flex;flex-direction:column;height:100vh;overflow:hidden}

    .header{height:50px;display:flex;align-items:center;justify-content:space-between;padding:0 12px;background:rgba(10,10,10,0.95);border-bottom:2px solid var(--yellow);z-index:1000}
    .logo{color:var(--yellow);font-weight:700;cursor:pointer}

    .main-container{flex:1;display:flex;flex-direction:column;overflow:hidden}

    .input-panel{background:rgba(10,10,10,0.95);padding:12px;overflow:auto;transition:height .12s,opacity .12s;min-height:0}
    .section{margin-bottom:12px}
    .section-title{font-size:.75rem;color:var(--yellow);margin-bottom:8px;text-transform:uppercase}
    select,textarea,input{width:100%;background:var(--glass);color:var(--text);border:1px solid var(--border);padding:8px;border-radius:6px;font-family:inherit;margin-bottom:8px}
    textarea{min-height:80px;resize:vertical}
    .send-btn{background:var(--yellow);color:var(--bg);border:none;padding:10px 14px;border-radius:6px;font-weight:700}

    .resize-divider{height:8px;background:var(--yellow);cursor:ns-resize;border-top:1px solid var(--border);border-bottom:1px solid var(--border);flex-shrink:0}
    .canvas{flex:1;overflow:auto;padding:8px;background:var(--bg)}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:8px;align-items:start}

    .flip-card{position:relative;border-radius:8px;border:2px solid var(--border);overflow:hidden;background:var(--bg);min-height:var(--card-min-height)}
    .flip-card-inner{width:100%;height:100%;transition:transform .6s;transform-style:preserve-3d;border-radius:8px}
    .flip-card.flipped .flip-card-inner{transform:rotateY(180deg)}

    .card-face{position:absolute;width:100%;height:100%;backface-visibility:hidden;display:flex;flex-direction:column;padding:12px;border-radius:8px;background:var(--glass)}
    .card-front{border-left:4px solid var(--yellow);background:linear-gradient(135deg, rgba(255,215,0,0.06), rgba(255,215,0,0.02))}
    .card-back{transform:rotateY(180deg);border-left:4px solid var(--blue);background:linear-gradient(135deg, rgba(100,150,255,0.06), rgba(100,150,255,0.02))}
    .question-div{flex:1;overflow:auto;white-space:pre-wrap;word-break:break-word;padding-right:4px;cursor:default}
    .response-content{flex:1;overflow:auto;white-space:pre-wrap;word-break:break-word;font-family:monospace;padding-right:4px}

    .card-actions{display:flex;gap:8px;margin-top:8px;border-top:1px solid var(--border);padding-top:6px;justify-content:flex-end;flex-wrap:wrap}
    .card-btn{background:rgba(0,0,0,0.5);border:none;color:var(--text);width:36px;height:36px;border-radius:50%;display:inline-flex;align-items:center;justify-content:center;cursor:pointer;padding:6px}

    /* vector icon styling and drop shadow */
    .icon {width:18px;height:18px;display:block}
    .card-btn svg, .fullscreen-card-btn svg {width:18px;height:18px;filter:drop-shadow(0 2px 3px rgba(0,0,0,0.6));}
    .fullscreen-card-btn{background:rgba(0,0,0,0.45);border:none;color:var(--text);width:40px;height:40px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;cursor:pointer}

    .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.9);z-index:2000;align-items:center;justify-content:center;padding:20px;overflow:auto}
    .modal.show{display:flex}
    .modal-content{background:var(--glass);border:2px solid var(--yellow);border-radius:12px;padding:18px;width:100%;max-width:960px;max-height:90vh;overflow:auto}

    .fullscreen-overlay{display:none;position:fixed;inset:0;background:var(--bg);z-index:3000;align-items:center;justify-content:center;padding:20px;overflow:hidden;border:4px solid var(--yellow);border-radius:12px;box-shadow:0 0 50px rgba(255,215,0,0.2)}
    .fullscreen-overlay.show{display:flex}
    .fullscreen-overlay.streaming::before{content:'Streaming...';position:absolute;top:10px;right:10px;background:var(--yellow);color:var(--bg);padding:4px 8px;border-radius:4px;font-size:0.8rem;font-weight:bold;z-index:3001}
    .fullscreen-main-content{width:96%;height:94%;max-width:1200px;max-height:86vh;display:flex;flex-direction:column;background:transparent}
    .fullscreen-card-inner{width:100%;height:100%;transition:transform .6s;transform-style:preserve-3d;border-radius:8px;position:relative}
    .fullscreen-card-inner.flipped{transform:rotateY(180deg)}
    .fullscreen-card-face{position:absolute;width:100%;height:100%;backface-visibility:hidden;display:flex;flex-direction:column;padding:20px;border-radius:8px;background:var(--glass);box-shadow:inset 0 0 20px rgba(0,0,0,0.6)}
    .fullscreen-card-face.card-front{border-left:4px solid var(--yellow)}
    .fullscreen-card-face.card-back{transform:rotateY(180deg);border-left:4px solid var(--blue)}

    .fullscreen-question-text{font-weight:700;color:var(--yellow);margin-bottom:12px}
    .fullscreen-response-content{flex:1;overflow:auto;white-space:pre-wrap;word-break:break-word;padding-right:8px;font-family:'Consolas','Monaco','Courier New',monospace;line-height:1.5;font-size:16px}

    .loading{position:fixed;bottom:18px;right:18px;background:var(--glass);padding:12px 16px;border-radius:8px;border:1px solid var(--yellow);display:none;z-index:999}
    .loading.show{display:block}
    .saved-notice{position:fixed;bottom:18px;left:50%;transform:translateX(-50%);background:rgba(0,255,0,0.08);color:#0f0;border:1px solid #0f0;padding:10px 14px;border-radius:8px;z-index:999;opacity:0;transition:opacity .18s}
    .saved-notice.show{opacity:1}

    /* Streaming animations */
    .streaming-cursor{display:inline-block;width:8px;height:1em;background-color:var(--yellow);margin-left:2px;animation:blink 1s infinite;vertical-align:middle}
    @keyframes blink{0%,100%{opacity:1}50%{opacity:0}}
    .streaming-indicator{position:absolute;top:10px;right:10px;color:var(--yellow);font-size:0.8rem;animation:pulse 1.5s infinite}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}

    /* compose modal large textarea */
    .compose-text{min-height:300px;max-height:70vh;resize:vertical;width:100%;padding:12px;border-radius:8px;background:var(--bg);border:1px solid var(--border);color:var(--text)}
  </style>
</head>
<body>
  <div class="header">
    <div class="logo" id="logoBtn">ai-nspired.com</div>
    <div style="display:flex;gap:10px;align-items:center">
      <button id="settingsOpenBtn">Settings</button>
      <button id="runTestsBtn" class="send-btn">Run tests</button>
    </div>
  </div>

  <div class="main-container">
    <div class="input-panel" id="inputPanel">
      <div class="section">
        <div class="section-title">Mode</div>
        <select id="modeSelect">
          <option value="chat">Chat</option>
          <option value="code">Code</option>
          <option value="generate">Generate</option>
        </select>
      </div>

      <div class="section">
        <div class="section-title">Message / Prompt</div>
        <textarea id="userInput" placeholder="you can ask whatever you like..."></textarea>
        <div style="display:flex;gap:10px">
          <button id="sendBtn" class="send-btn">send</button>
          <button id="composeOpenBtn" class="send-btn" title="Open larger compose box">Compose</button>
        </div>
      </div>
    </div>

    <div class="resize-divider" id="resizeDivider" title="Drag to resize • Double-click to toggle collapse"></div>

    <div class="canvas" id="canvas">
      <div class="grid" id="grid"></div>
    </div>
  </div>

  <div class="saved-notice" id="savedNotice">Saved!</div>
  <div class="loading" id="loading">Processing...</div>

  <!-- Settings -->
  <div class="modal" id="settingsModal" aria-hidden="true">
    <div class="modal-content">
      <div style="font-size:1.2rem;color:var(--yellow);margin-bottom:12px;text-align:center">Settings</div>
      <div class="section"><div class="section-title">API Base URL</div><input id="baseUrl" placeholder="https://your-worker.workers.dev"/></div>
      <div class="section"><div class="section-title">Session ID</div><input id="sessionIdInput" readonly/></div>
      <div style="display:flex;gap:10px;margin-top:12px">
        <button id="exportBtn">Export</button>
        <label for="importFile" class="send-btn" style="cursor:pointer">Import</label>
        <input id="importFile" type="file" accept=".json" style="display:none"/>
      </div>
      <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px">
        <button id="settingsCancelBtn">Cancel</button>
        <button id="settingsSaveBtn" class="send-btn">Save</button>
      </div>
    </div>
  </div>

  <!-- Edit -->
  <div class="modal" id="editModal" aria-hidden="true">
    <div class="modal-content">
      <div style="font-size:1.1rem;color:var(--yellow);margin-bottom:12px">Edit Tile <span id="editTileIdDisplay"></span></div>
      <div class="section"><div class="section-title">Question / Intro</div><textarea id="editQuestion"></textarea></div>
      <div class="section">
        <div class="section-title">Response Markdown <button id="editTogglePreview" type="button">Preview</button></div>
        <textarea id="editResponse"></textarea>
        <div class="markdown-preview" id="editPreview" style="display:none"></div>
      </div>
      <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px">
        <button id="editCancelBtn">Cancel</button>
        <button id="editSaveBtn" class="send-btn">Save</button>
      </div>
    </div>
  </div>

  <!-- Compose (full text) -->
  <div class="modal" id="composeModal" aria-hidden="true">
    <div class="modal-content">
      <div style="font-size:1.1rem;color:var(--yellow);margin-bottom:12px">Compose — larger editor</div>
      <textarea id="composeInput" class="compose-text" placeholder="Write long content here..."></textarea>
      <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px">
        <button id="composeCancelBtn">Cancel</button>
        <button id="composeSendBtn" class="send-btn">Send</button>
      </div>
    </div>
  </div>

  <!-- Fullscreen -->
  <div class="fullscreen-overlay" id="fullscreenOverlay" aria-hidden="true">
    <div class="fullscreen-main-content">
      <div class="fullscreen-card-inner" id="fullscreenInner">
        <div class="fullscreen-card-face card-front">
          <div class="fullscreen-question-text"></div>
          <div class="fullscreen-response-content"></div>
          <div style="margin-top:12px;display:flex;gap:10px;justify-content:flex-end">
            <button class="fullscreen-card-btn" data-action="flip" title="Flip">
              <!-- flip icon -->
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12v6a2 2 0 0 1-2 2H7"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12V6a2 2 0 0 1 2-2h12"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 9l-4 4 4 4"/></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="edit" title="Edit">
              <!-- edit icon -->
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20h9"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.5 3.5l4 4L8 20H4v-4L16.5 3.5z"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="followup" title="Follow up">
              <!-- arrow right -->
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5l7 7-7 7"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="delete" title="Delete">
              <!-- trash -->
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6h18"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 6v14a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 11v6"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 11v6"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="close" title="Close">
              <!-- close -->
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
          </div>
        </div>

        <div class="fullscreen-card-face card-back">
          <div class="fullscreen-question-text"></div>
          <div class="fullscreen-response-content"></div>
          <div style="margin-top:12px;display:flex;gap:10px;justify-content:flex-end">
            <button class="fullscreen-card-btn" data-action="flip" title="Flip">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12v6a2 2 0 0 1-2 2H7"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12V6a2 2 0 0 1 2-2h12"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 9l-4 4 4 4"/></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="edit" title="Edit">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20h9"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.5 3.5l4 4L8 20H4v-4L16.5 3.5z"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="followup" title="Follow up">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5l7 7-7 7"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="delete" title="Delete">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6h18"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 6v14a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 11v6"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 11v6"></path></svg>
            </button>
            <button class="fullscreen-card-btn" data-action="close" title="Close">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
// Core variables
let pairs = [];
let history = [];
let sessionId = "main-" + Date.now();
let accumulatedAIResponse = "";
let currentTileIdForStreaming = null;
let editingTileId = null;
let currentFullscreenTileId = null;
const textDecoder = (typeof TextDecoder !== 'undefined') ? new TextDecoder('utf-8') : null;

// DOM Elements
const gridElement = document.getElementById('grid');
const userInputElement = document.getElementById('userInput');
const modeSelectElement = document.getElementById('modeSelect');
const baseUrlInput = document.getElementById('baseUrl');
const sessionIdInput = document.getElementById('sessionIdInput');
const settingsModal = document.getElementById('settingsModal');
const editModal = document.getElementById('editModal');
const editQuestionTextarea = document.getElementById('editQuestion');
const editResponseTextarea = document.getElementById('editResponse');
const editPreviewDiv = document.getElementById('editPreview');
const editTogglePreviewBtn = document.getElementById('editTogglePreview');
const editTileIdDisplaySpan = document.getElementById('editTileIdDisplay');
const loadingIndicator = document.getElementById('loading');
const savedNotice = document.getElementById('savedNotice');

const resizeDivider = document.getElementById('resizeDivider');
const inputPanelElement = document.getElementById('inputPanel');

const fullscreenOverlay = document.getElementById('fullscreenOverlay');
const fullscreenCardInner = document.getElementById('fullscreenInner');
const fullscreenQuestionTexts = fullscreenOverlay.querySelectorAll('.fullscreen-question-text');
const fullscreenResponseContents = fullscreenOverlay.querySelectorAll('.fullscreen-response-content');

const composeModal = document.getElementById('composeModal');
const composeInput = document.getElementById('composeInput');

// Storage keys
const STORAGE_DATA_KEY = 'mindmap-data';
const STORAGE_BASEURL_KEY = 'mindmap-baseUrl';
const STORAGE_DIVIDER_HEIGHT_KEY = 'mindmap-divider-height';

// Utility functions
function escapeHTML(str = '') {
  const d = document.createElement('div');
  d.appendChild(document.createTextNode(String(str)));
  return d.innerHTML;
}

function safeRenderMarkdown(md) {
  const html = marked.parse(md || '');
  return DOMPurify.sanitize(html);
}

function getBaseUrl() {
  return (baseUrlInput.value || '').trim().replace(/\/+$/, '');
}

// Update card min-height based on available space
function updateCardMinHeight() {
  const canvas = document.getElementById('canvas');
  if (!canvas) return;

  const inputHeight = inputPanelElement.getBoundingClientRect().height || 0;
  const availableHeight = window.innerHeight - inputHeight - 100; // Account for header and margins
  const targetHeight = Math.max(150, Math.min(availableHeight * 0.4, 400));

  document.documentElement.style.setProperty('--card-min-height', targetHeight + 'px');
}

// Add new tile pair
function addPair(p) {
  const id = (window.crypto && typeof crypto.randomUUID === 'function') ? crypto.randomUUID() : `id-${Date.now()}-${Math.floor(Math.random() * 100000)}`;
  pairs.push({
    id,
    question: p.question,
    response: p.response || '',
    sessionId: p.sessionId || sessionId
  });
  renderPair(pairs[pairs.length - 1]);
  save();
  updateCardMinHeight();
  return id;
}

// Render tile to grid (uses inline SVG icons)
function renderPair(p) {
  let responseHTML = 'Waiting for AI...';
  if (p.response && p.response !== '...' && !p.response.startsWith('Error:')) {
    responseHTML = safeRenderMarkdown(p.response);
  } else if (p.response === '...') {
    responseHTML = '<div class="streaming-indicator"><span class="streaming-cursor"></span> Streaming...</div>';
  } else if (p.response && p.response.startsWith('Error:')) {
    responseHTML = `<p style="color:red">${escapeHTML(p.response)}</p>`;
  }

  const card = document.createElement('div');
  card.className = 'flip-card';
  card.dataset.id = p.id;

  card.innerHTML = `
    <div class="flip-card-inner">
      <div class="card-face card-front">
        <div class="question-div" data-id="${p.id}">${escapeHTML(p.question)}</div>
        <div class="card-actions">
          <button class="card-btn" data-action="show-fullscreen" data-id="${p.id}" title="Fullscreen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7V4h3M20 7V4h-3M4 17v3h3M20 17v3h-3"/></svg>
          </button>
          <button class="card-btn" data-action="edit" data-id="${p.id}" title="Edit">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20h9M16.5 3.5l4 4L8 20H4v-4L16.5 3.5z"/></svg>
          </button>
          <button class="card-btn delete" data-action="delete" data-id="${p.id}" title="Delete">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6h18M8 6v14a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6"/></svg>
          </button>
          <button class="card-btn" data-action="copy" data-id="${p.id}" title="Copy">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><rect x="9" y="9" width="13" height="13" rx="2"/><rect x="2" y="2" width="13" height="13" rx="2"/></svg>
          </button>
          <button class="card-btn" data-action="followup" data-id="${p.id}" title="Follow Up">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5l7 7-7 7"/></svg>
          </button>
        </div>
      </div>

      <div class="card-face card-back">
        <div class="response-content">${responseHTML}</div>
        <div class="card-actions">
          <button class="card-btn" data-action="show-fullscreen" data-id="${p.id}" title="Fullscreen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7V4h3M20 7V4h-3M4 17v3h3M20 17v3h-3"/></svg>
          </button>
          <button class="card-btn" data-action="edit" data-id="${p.id}" title="Edit">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20h9M16.5 3.5l4 4L8 20H4v-4L16.5 3.5z"/></svg>
          </button>
          <button class="card-btn" data-action="copy" data-id="${p.id}" title="Copy">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" class="icon"><rect x="9" y="9" width="13" height="13" rx="2"/><rect x="2" y="2" width="13" height="13" rx="2"/></svg>
          </button>
        </div>
      </div>
    </div>
  `;

  // Flip on click (excluding buttons)
  card.addEventListener('click', e => {
    if (e.target.closest('.card-btn') || e.target.closest('.card-actions')) return;
    card.classList.toggle('flipped');
  });

  gridElement.appendChild(card);
}

// Update tile response with streaming support
function updateTileResponseContent(tileId, content, isStreaming = false) {
  // Update grid card
  const card = gridElement.querySelector(`[data-id="${tileId}"]`);
  if (card) {
    const responseElement = card.querySelector('.card-back .response-content');
    if (responseElement) {
      if (isStreaming) {
        // Append streaming text as plain text to avoid intermediate HTML injection
        responseElement.textContent = (responseElement.textContent || '') + content;
        responseElement.scrollTop = responseElement.scrollHeight;
      } else {
        // Final markdown render (HTML)
        responseElement.innerHTML = content;
      }
    }
  }

  // Update fullscreen if open for this tile
  if (currentFullscreenTileId === tileId) {
    fullscreenResponseContents.forEach(el => {
      if (isStreaming) {
        el.textContent = (el.textContent || '') + content;
      } else {
        el.innerHTML = content;
      }
      el.scrollTop = el.scrollHeight;
    });
  }
}

// Process streaming response with auto-fullscreen
async function processSSEStream(reader, tileId) {
  // Auto-open fullscreen for the streaming tile but only when streaming starts from sendMessage flow (we already call this from sendMessage)
  showFullscreen(tileId);
  fullscreenOverlay.classList.add('streaming');

  let buffer = '';
  accumulatedAIResponse = '';

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunkText = textDecoder ? textDecoder.decode(value, { stream: true }) : new TextDecoder('utf-8').decode(value);
      buffer += chunkText;

      const parts = buffer.split(/\r?\n\r?\n/);
      buffer = parts.pop() || '';

      for (const part of parts) {
        if (!part) continue;

        const lines = part.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
        for (const line of lines) {
          if (line.startsWith('data:')) {
            const dataStr = line.substring(5).trim();
            if (dataStr === '[DONE]') {
              const safeHTML = safeRenderMarkdown(accumulatedAIResponse);
              updateTileResponseContent(tileId, safeHTML, false);

              const tile = pairs.find(t => t.id === tileId);
              if (tile) tile.response = accumulatedAIResponse;
              save();

              fullscreenOverlay.classList.remove('streaming');
              return;
            }

            try {
              const data = JSON.parse(dataStr);
              const content = data.choices?.[0]?.delta?.content;
              if (content) {
                accumulatedAIResponse += content;
                updateTileResponseContent(tileId, content, true);
              } else {
                accumulatedAIResponse += dataStr;
                updateTileResponseContent(tileId, dataStr, true);
              }
            } catch (err) {
              accumulatedAIResponse += dataStr;
              updateTileResponseContent(tileId, dataStr, true);
            }
          } else {
            accumulatedAIResponse += line;
            updateTileResponseContent(tileId, line, true);
          }
        }
      }
    }
  } catch (err) {
    console.error('Stream error', err);
    updateTileResponseContent(tileId, `<p style="color:red">Stream error: ${escapeHTML(err.message || String(err))}</p>`, false);
  } finally {
    fullscreenOverlay.classList.remove('streaming');

    if (accumulatedAIResponse) {
      const safeHTML = safeRenderMarkdown(accumulatedAIResponse);
      updateTileResponseContent(tileId, safeHTML, false);

      const tile = pairs.find(t => t.id === tileId);
      if (tile) tile.response = accumulatedAIResponse;
      save();
    }

    updateCardMinHeight();
  }
}

// API fetch with streaming support
async function apiFetch(path, payload) {
  const base = getBaseUrl();
  if (!base) throw new Error('API Base URL not set.');

  const url = base + path;
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  if (!res.ok) {
    let msg = `HTTP ${res.status}`;
    try {
      const j = await res.json();
      msg = j.error || j.message || JSON.stringify(j);
    } catch {}
    throw new Error(msg);
  }

  if (res.body && typeof res.body.getReader === 'function') {
    return res.body.getReader();
  }

  // Fallback for non-streaming responses: convert text into a reader
  const text = await res.text().catch(() => '');
  const enc = new TextEncoder();
  const chunk = enc.encode(text);
  const stream = new ReadableStream({
    start(ctrl) {
      if (chunk && chunk.length) ctrl.enqueue(chunk);
      ctrl.close();
    }
  });

  return stream.getReader();
}

// Send message to AI
async function sendMessage() {
  const input = (userInputElement.value || '').trim();
  if (!input) return;

  const mode = modeSelectElement.value || 'chat';
  userInputElement.value = '';
  loadingIndicator.classList.add('show');

  try {
    const payload = { sessionId };
    if (mode === 'chat') {
      payload.message = input;
    } else {
      payload.prompt = input;
    }

    const path = mode === 'code' ? '/api/code' : mode === 'generate' ? '/api/generate' : '/api/chat';

    // Create new tile for streaming
    currentTileIdForStreaming = addPair({ question: input, response: '...' });

    // Get stream reader and process
    const reader = await apiFetch(path, payload);
    await processSSEStream(reader, currentTileIdForStreaming);
  } catch (err) {
    const msg = err?.message ? err.message : String(err);

    if (currentTileIdForStreaming) {
      updateTileResponseContent(currentTileIdForStreaming, `<p style="color:red">Error: ${escapeHTML(msg)}</p>`, false);
      const tile = pairs.find(x => x.id === currentTileIdForStreaming);
      if (tile) tile.response = `Error: ${msg}`;
      save();
    } else {
      alert(msg);
    }
  } finally {
    loadingIndicator.classList.remove('show');
    currentTileIdForStreaming = null;
    updateCardMinHeight();
  }
}

// Tile actions
function deletePair(id) {
  pairs = pairs.filter(p => p.id !== id);
  const el = document.querySelector(`[data-id="${id}"]`);
  if (el) el.remove();
  save();

  if (currentFullscreenTileId === id) {
    hideFullscreen();
  }
}

function copyResponse(id) {
  const el = document.querySelector(`[data-id="${id}"] .card-back .response-content`);
  const txt = el ? (el.textContent || '') : '';
  navigator.clipboard.writeText(txt)
    .then(() => showSavedNotice('Copied!'))
    .catch(() => alert('Copy failed'));
}

function sendTileToAI(id) {
  const tile = pairs.find(p => p.id === id);
  if (!tile) return;

  const resp = document.querySelector(`[data-id="${id}"] .card-back .response-content`)?.textContent || '';
  userInputElement.value = `${tile.question}\n\n---\n\n${resp.slice(0, 1000)}`;
  userInputElement.focus();
}

// Fullscreen functions (only open via show-fullscreen action)
function showFullscreen(id) {
  const tile = pairs.find(p => p.id === id);
  if (!tile) return;

  currentFullscreenTileId = id;

  // Set question text in both sides
  fullscreenQuestionTexts.forEach(el => {
    el.textContent = tile.question || '';
  });

  // Set response content in both sides
  fullscreenResponseContents.forEach(el => {
    if (currentTileIdForStreaming === id && accumulatedAIResponse) {
      el.textContent = accumulatedAIResponse;
    } else {
      el.innerHTML = tile.response ? safeRenderMarkdown(tile.response) : 'No response yet';
    }
    el.scrollTop = el.scrollHeight;
  });

  // Auto-flip to response side for better viewing
  fullscreenCardInner.classList.add('flipped');

  // Show overlay
  fullscreenOverlay.classList.add('show');
  fullscreenOverlay.setAttribute('aria-hidden', 'false');

  updateCardMinHeight();
}

function hideFullscreen() {
  fullscreenOverlay.classList.remove('show');
  fullscreenOverlay.classList.remove('streaming');
  fullscreenOverlay.setAttribute('aria-hidden', 'true');
  currentFullscreenTileId = null;
  fullscreenCardInner.classList.remove('flipped');
}

function flipFullscreen() {
  fullscreenCardInner.classList.toggle('flipped');
}

// Edit modal functions
function showEditModal(id) {
  editingTileId = id;
  const tile = pairs.find(p => p.id === id);
  if (!tile) return;

  editTileIdDisplaySpan.textContent = `#${id.slice(0, 8)}`;
  editQuestionTextarea.value = tile.question || '';
  editResponseTextarea.value = tile.response || '';
  editPreviewDiv.style.display = 'none';
  editPreviewDiv.innerHTML = '';

  editModal.classList.add('show');
  editModal.setAttribute('aria-hidden', 'false');
  hideFullscreen();
}

function closeEditModal() {
  editingTileId = null;
  editModal.classList.remove('show');
  editModal.setAttribute('aria-hidden', 'true');
}

function saveEditedTile() {
  if (!editingTileId) return closeEditModal();

  const tile = pairs.find(p => p.id === editingTileId);
  if (!tile) return closeEditModal();

  tile.question = (editQuestionTextarea.value || '').trim();
  tile.response = (editResponseTextarea.value || '').trim();

  // Update UI
  const card = gridElement.querySelector(`[data-id="${tile.id}"]`);
  if (card) {
    const questionDiv = card.querySelector('.card-front .question-div');
    if (questionDiv) questionDiv.textContent = tile.question;

    const responseDiv = card.querySelector('.card-back .response-content');
    if (responseDiv) responseDiv.innerHTML = safeRenderMarkdown(tile.response);
  }

  save();
  showSavedNotice();
  closeEditModal();

  if (currentFullscreenTileId === tile.id) {
    showFullscreen(tile.id);
  }
}

function toggleEditPreview() {
  if (editPreviewDiv.style.display === 'none') {
    editPreviewDiv.innerHTML = safeRenderMarkdown(editResponseTextarea.value);
    editPreviewDiv.style.display = 'block';
    editTogglePreviewBtn.textContent = 'Hide Preview';
  } else {
    editPreviewDiv.style.display = 'none';
    editTogglePreviewBtn.textContent = 'Preview';
  }
}

// Settings functions
function showSettings() {
  baseUrlInput.value = localStorage.getItem(STORAGE_BASEURL_KEY) || '';
  sessionIdInput.value = sessionId;
  settingsModal.classList.add('show');
  settingsModal.setAttribute('aria-hidden', 'false');
}

function closeSettings() {
  settingsModal.classList.remove('show');
  settingsModal.setAttribute('aria-hidden', 'true');
}

function saveSettings() {
  localStorage.setItem(STORAGE_BASEURL_KEY, (baseUrlInput.value || '').trim());
  closeSettings();
  showSavedNotice();
}

function exportData() {
  const data = { pairs, history, sessionId };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `mindmap-${new Date().toISOString().slice(0, 10)}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 500);
}

function importData(file) {
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      pairs = data.pairs || [];
      history = data.history || [];
      sessionId = data.sessionId || sessionId;

      gridElement.innerHTML = '';
      pairs.forEach(renderPair);
      save();
      showSavedNotice('Imported!');
    } catch (err) {
      alert('Invalid file: ' + (err.message || err));
    }
  };
  reader.readAsText(file);
}

// Storage functions
function save() {
  try {
    localStorage.setItem(STORAGE_DATA_KEY, JSON.stringify({ pairs, history, sessionId }));
  } catch (e) {
    console.warn('Failed to save:', e);
  }
}

function load() {
  try {
    const raw = localStorage.getItem(STORAGE_DATA_KEY);
    if (raw) {
      const data = JSON.parse(raw);
      pairs = data.pairs || [];
      history = data.history || [];
      sessionId = data.sessionId || sessionId;
      pairs.forEach(renderPair);
    }
  } catch (e) {
    console.warn('Failed to load:', e);
  }

  const savedUrl = localStorage.getItem(STORAGE_BASEURL_KEY);
  if (savedUrl) baseUrlInput.value = savedUrl;

  const savedHeight = localStorage.getItem(STORAGE_DIVIDER_HEIGHT_KEY);
  if (savedHeight) {
    applyInputPanelHeight(parseFloat(savedHeight));
  } else {
    applyInputPanelHeight(200);
  }

  updateCardMinHeight();
}

// Panel resize functions
function applyInputPanelHeight(height) {
  const maxHeight = window.innerHeight * 0.8;
  const newHeight = Math.max(0, Math.min(height || 0, maxHeight));

  if (newHeight <= 2) {
    inputPanelElement.style.height = '0px';
    inputPanelElement.style.opacity = '0';
    inputPanelElement.style.overflow = 'hidden';
  } else {
    inputPanelElement.style.height = newHeight + 'px';
    inputPanelElement.style.opacity = '1';
    inputPanelElement.style.overflow = 'auto';
    localStorage.setItem(STORAGE_DIVIDER_HEIGHT_KEY, newHeight);
  }

  updateCardMinHeight();
}

// Divider mouse events
let resizing = false;
let startY = 0;
let startHeight = 0;

resizeDivider.addEventListener('mousedown', e => {
  resizing = true;
  startY = e.clientY;
  startHeight = inputPanelElement.getBoundingClientRect().height;
  document.body.style.userSelect = 'none';
});

document.addEventListener('mousemove', e => {
  if (!resizing) return;
  const delta = e.clientY - startY;
  applyInputPanelHeight(startHeight + delta);
});

document.addEventListener('mouseup', () => {
  if (resizing) {
    resizing = false;
    document.body.style.userSelect = '';
    localStorage.setItem(STORAGE_DIVIDER_HEIGHT_KEY, parseFloat(inputPanelElement.style.height || 0));
  }
});

// Divider touch events
resizeDivider.addEventListener('touchstart', e => {
  const touch = e.touches && e.touches[0];
  if (!touch) return;
  resizing = true;
  startY = touch.clientY;
  startHeight = inputPanelElement.getBoundingClientRect().height;
}, { passive: false });

document.addEventListener('touchmove', e => {
  if (!resizing) return;
  const touch = e.touches && e.touches[0];
  if (!touch) return;
  const delta = touch.clientY - startY;
  applyInputPanelHeight(startHeight + delta);
}, { passive: false });

document.addEventListener('touchend', () => {
  if (resizing) {
    resizing = false;
    localStorage.setItem(STORAGE_DIVIDER_HEIGHT_KEY, parseFloat(inputPanelElement.style.height || 0));
  }
});

// Double-click to toggle collapse
resizeDivider.addEventListener('dblclick', () => {
  const currentHeight = inputPanelElement.getBoundingClientRect().height;
  if (currentHeight <= 2) {
    applyInputPanelHeight(200);
    localStorage.setItem(STORAGE_DIVIDER_HEIGHT_KEY, 200);
  } else {
    applyInputPanelHeight(0);
    localStorage.setItem(STORAGE_DIVIDER_HEIGHT_KEY, 0);
  }
});

// Event delegation for card buttons
document.addEventListener('click', e => {
  const button = e.target.closest('[data-action]');
  if (!button) return;

  e.stopPropagation();
  const action = button.dataset.action;
  const id = button.dataset.id || button.closest('.flip-card')?.dataset.id;

  switch (action) {
    case 'show-fullscreen':
      if (id) showFullscreen(id);
      break;
    case 'edit':
      if (id) showEditModal(id);
      break;
    case 'delete':
      if (id && confirm('Delete this tile?')) deletePair(id);
      break;
    case 'copy':
      if (id) copyResponse(id);
      break;
    case 'followup':
      if (id) sendTileToAI(id);
      break;
    case 'flip':
      flipFullscreen();
      break;
    case 'close':
      hideFullscreen();
      break;
  }
});

// UI event listeners
document.getElementById('logoBtn').addEventListener('click', () => location.reload());
document.getElementById('settingsOpenBtn').addEventListener('click', showSettings);

document.getElementById('runTestsBtn').addEventListener('click', () => {
  try {
    const id = addPair({ question: 'self-test', response: 'ok' });
    if (!document.querySelector(`[data-id="${id}"]`)) throw new Error('render failed');
    deletePair(id);
    if (document.querySelector(`[data-id="${id}"]`)) throw new Error('delete failed');
    alert('✓ Self-tests passed');
  } catch (e) {
    alert('✖ Self-test failed: ' + e.message);
    console.error(e);
  }
});

document.getElementById('settingsSaveBtn').addEventListener('click', saveSettings);
document.getElementById('settingsCancelBtn').addEventListener('click', closeSettings);
document.getElementById('exportBtn').addEventListener('click', exportData);

document.getElementById('importFile').addEventListener('change', e => {
  const file = e.target.files && e.target.files[0];
  if (file) importData(file);
  e.target.value = '';
});

document.getElementById('sendBtn').addEventListener('click', sendMessage);
document.getElementById('editSaveBtn').addEventListener('click', saveEditedTile);
document.getElementById('editCancelBtn').addEventListener('click', closeEditModal);
document.getElementById('editTogglePreview').addEventListener('click', toggleEditPreview);

// Compose modal handlers
document.getElementById('composeOpenBtn').addEventListener('click', () => {
  composeInput.value = userInputElement.value || '';
  composeModal.classList.add('show');
  composeModal.setAttribute('aria-hidden', 'false');
});
document.getElementById('composeCancelBtn').addEventListener('click', () => {
  composeModal.classList.remove('show');
  composeModal.setAttribute('aria-hidden', 'true');
});
document.getElementById('composeSendBtn').addEventListener('click', () => {
  userInputElement.value = composeInput.value;
  composeModal.classList.remove('show');
  composeModal.setAttribute('aria-hidden', 'true');
  sendMessage();
});

// Close modals by clicking outside
document.addEventListener('click', e => {
  if (e.target === settingsModal) closeSettings();
  if (e.target === editModal) closeEditModal();
  if (e.target === fullscreenOverlay) hideFullscreen();
  if (e.target === composeModal) {
    composeModal.classList.remove('show');
    composeModal.setAttribute('aria-hidden', 'true');
  }
});

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  // Escape to close modals/fullscreen
  if (e.key === 'Escape') {
    if (fullscreenOverlay.classList.contains('show')) {
      hideFullscreen();
    } else if (editModal.classList.contains('show')) {
      closeEditModal();
    } else if (settingsModal.classList.contains('show')) {
      closeSettings();
    } else if (composeModal.classList.contains('show')) {
      composeModal.classList.remove('show');
      composeModal.setAttribute('aria-hidden', 'true');
    }
  }

  // Ctrl/Cmd + Enter to send message
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
    if (document.activeElement === userInputElement || document.activeElement === composeInput) {
      e.preventDefault();
      sendMessage();
    }
  }
});

// Helper functions
function showSavedNotice(text = 'Saved!') {
  savedNotice.textContent = text;
  savedNotice.classList.add('show');
  setTimeout(() => savedNotice.classList.remove('show'), 2000);
}

// Initialize
load();

// Expose for debugging
window.MindMap = { addPair, pairs };
</script>
</body>
</html>